# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "pycryptodome",
# ]
# ///

from Crypto.Cipher import AES

key = 0x8888  # 16 bit key
V = 0x0123456789ABCDEF0123456789ABCDEF  # 128 bit vector


def to_bytes(n: int) -> bytes:
    return n.to_bytes(16, byteorder="little")


def from_bytes(bytelist: bytes) -> int:
    return int.from_bytes(bytelist, byteorder="little")


cipher = AES.new(to_bytes(key), AES.MODE_ECB)

outputs = []
for _ in range(6):
    outputs.append(cipher.encrypt(to_bytes(V)))
    V += 1

# `outputs` now contain 6 randomish values
for i, val in enumerate(outputs, start=1):
    print(f"Output {i} : {from_bytes(val):#x}")


### BEGIN EXPLOIT

# search for key using first three numbers
cipher = None
for i in range(65536):
    trialkey = to_bytes(i)
    cipher = AES.new(trialkey, AES.MODE_ECB)

    try1 = from_bytes(cipher.decrypt(outputs[0]))
    try2 = from_bytes(cipher.decrypt(outputs[1]))
    try3 = from_bytes(cipher.decrypt(outputs[2]))

    if try3 == (try2 + 1) and (try2 == (try1 + 1)):
        print(f"Key {i:4} works")
        break

# predict next 3 values

predict1 = cipher.encrypt(to_bytes(try3 + 1))
predict2 = cipher.encrypt(to_bytes(try3 + 2))
predict3 = cipher.encrypt(to_bytes(try3 + 3))

print("=== Predicted Values ===")
print(f"{from_bytes(predict1):#x}")
print(f"{from_bytes(predict2):#x}")
print(f"{from_bytes(predict3):#x}")
